package com.atlassian.performance.tools.awsinfrastructure

import com.amazonaws.services.ec2.model.SecurityGroup
import com.atlassian.performance.tools.infrastructure.api.jira.JiraNodeConfig
import com.atlassian.performance.tools.io.api.readResourceText
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.node.ObjectNode
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.dataformat.yaml.YAMLGenerator
import org.apache.logging.log4j.LogManager
import org.apache.logging.log4j.Logger

// This is a workaround for JPT-296. Please use EC2 API instead of template hacking when fixed.
internal class TemplateBuilder(
    private val baseTemplateName: String
) {
    private val logger: Logger = LogManager.getLogger(this::class.java)
    private val template = readResourceText("aws/$baseTemplateName").replace("!Ref", "__Ref__")

    private val mapper = ObjectMapper(YAMLFactory()
        .enable(YAMLGenerator.Feature.MINIMIZE_QUOTES)
        .disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER))
    private val mappedTemplate = mapper.readTree(template)

    fun adaptTo(
        configs: List<JiraNodeConfig>
    ): String {
        // HACK: we open all the ports for all the nodes, because they all reuse the same security group
        val allPorts = configs
            .flatMap { it.debug.getRequiredPorts() + it.splunkForwarder.getRequiredPorts() + it.remoteJmx.getRequiredPorts() }
            .toSet()
        addSecurityGroupIngress(allPorts)
        setNodesCount(configs.size)
        replaceDescription { oldDescription ->
            oldDescription
                ?.replace(Regex("\\d node"), "${configs.size} node")
                ?: "Serves a ${configs.size} node Jira without a load balancer"
        }
        return build()
    }

    fun addSecurityGroupIngress(
        ports: Set<Int>,
        securityGroupName: String = "TomcatSecurityGroup"
    ): TemplateBuilder = apply {
        ports.forEach { port ->
            addSecurityGroupIngress(
                newResourceKey = nextIndexedResourceKey("port${port}PublicAccess"),
                groupId = getResourceReference(securityGroupName),
                ports = port..port,
                permittedCidrIpv4 = "0.0.0.0/0"
            )
        }
    }

    fun addSecurityGroupIngress(
        newResourceKey: String,
        groupId: String,
        ports: IntRange,
        permittedSecurityGroup: SecurityGroup? = null,
        permittedCidrIpv4: String? = null,
        permittedCidrIpv6: String? = null,
        description: String? = "Ingress rule generated by TemplateBuilder",
        ipProtocol: String = "tcp"
    ): TemplateBuilder = apply {
        val resources = mappedTemplate.get("Resources") as ObjectNode

        if (resources.has(newResourceKey)) {
            throw IllegalArgumentException("Resource with name $newResourceKey already exists in YAML built from $baseTemplateName: \n${toString()}")
        }

        val newResourceProperties = resources
            .putObject(newResourceKey)
            .put("Type", "AWS::EC2::SecurityGroupIngress")
            .putObject("Properties")

        newResourceProperties
            .put("GroupId", groupId)
            .put("IpProtocol", ipProtocol)
            .put("FromPort", ports.first)
            .put("ToPort", ports.last)
            .also {
                if (permittedSecurityGroup != null) {
                    it.put("SourceSecurityGroupId", permittedSecurityGroup.groupId)
                    it.put("SourceSecurityGroupOwnerId", permittedSecurityGroup.ownerId)
                }
            }
            .also { if (permittedCidrIpv4 != null) { it.put("CidrIp", permittedCidrIpv4) } }
            .also { if (permittedCidrIpv6 != null) { it.put("CidrIpv6", permittedCidrIpv6) } }
            .also { if (description != null) { it.put("Description", description) } }
    }

    fun setNodesCount(
        desiredNodesCount: Int
    ): TemplateBuilder = apply {
        val existingNodes: MutableList<String> = mutableListOf()
        val resources = mappedTemplate.get("Resources") as ObjectNode

        for (resource in resources.fieldNames()) {
            if (resource.startsWith("jira", ignoreCase = true) &&
                resources.get(resource).get("Type").asText() == "AWS::EC2::Instance") {
                logger.debug("Existing Jira node in $baseTemplateName: $resource")
                existingNodes.add(resource)
            }
        }
        if (existingNodes.count() == desiredNodesCount) {
            return this
        }

        val nodeTemplate = resources.get(existingNodes[0])
        for (existingNode in existingNodes) {
            resources.remove(existingNode)
        }
        for (nodeNumber in 1..desiredNodesCount) {
            resources.set("jira$nodeNumber", nodeTemplate)
        }
    }

    fun replaceDescription(
        descriptionTransform: (String?) -> String
    ): TemplateBuilder = apply {
        (mappedTemplate as ObjectNode).let {
            val currentDescription = when {
                it.has("Description") -> it.get("Description").asText()
                else -> null
            }
            it.put("Description", descriptionTransform(currentDescription))
        }
    }

    fun getResourceReference(
        key: String
    ) = "__Ref__ $key"

    fun nextIndexedResourceKey(
        prefix: String
    ) = prefix + (mappedTemplate.get("Resources") as ObjectNode)
        .fieldNames()
        .asSequence()
        .toSet()
        .let { existingKeys ->
            (0..9000).find { !existingKeys.contains("$prefix$it") }
                ?: throw RuntimeException("There are over 9000 resources prefixed with $prefix. Generating higher indexes of resource keys is unsupported.")
        }

    override fun toString() = mapper
        .writerWithDefaultPrettyPrinter()
        .writeValueAsString(mappedTemplate)
        .replace("__Ref__", "!Ref")

    fun build() = toString()
        .also { logger.debug("Transformed $baseTemplateName into: \n$it") }
}